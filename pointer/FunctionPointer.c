#include<stdio.h>

/*
	변수만 메모리 공간에 저장되는 것은 아니다. 프로그램 실행의 흐름을 구성하는 함수들도 바이너리 형태로 메모리 공간에 저장되어서 호출 시 실행된다.
	그리고 이렇게 메모리상에 저장된 함수의 주소 값을 저장하는 포인터 변수가 바로 '함수 포인터 변수' 이다.
*/

int main() {
	// 프로그래머가 정의하는 모든 함수는 프로그램 실행 시 '메인 메모리'에 저장되어서 실행된다.
	// "배열의 이름 == 포인터 시작 주소" 처럼
	// "함수의 이름 == 함수가 저장된 메모리 공간의 주소 값 의미"
	// 배열의 이름과 마찬가지로 함수의 이름도 그 형태가 상수이다.
	// 그런데, 이러한 함수의 주소 값 저장을 위한 포인터 변수를 별도로 선언할 수 있으며, 이러한 용도로 선언된 포인터 변수를 가리켜 [함수 포인터 변수]라고 한다.
}


/*
	int SimpleFunc(int num){....}
	이 함수의 반환형은 int 이며, 매개변수는 int num 이다. 그리고 함수의 이름은 곧 함수를 가리키는 포인터가 된다.
	그렇다면 함수의 형(type)은?
	이는 반환형과 매개변수의 선언형태를 기준으로 구분한다.

	ex) double ComplexFunc(double num1, double num2){...} 과 같이 정의된 함수 이름의 포인터형은?
	반환형이 double이고, 매개변수로 두 개의 double 형 변수가 선언된 포인터 형(type)이다.

	함수의 주소 값(함수 포인터 값)을 저장할 수 있는 포인터 변수는 어떻게 선언할까?
	이 포인터 변수에는 반환형, 매개변수 선언의 정보가 담겨있어야 한다. 선언은 다음과 같다.

	[ int (*fptr) (double); ]
	int: 반환형
	(*fptr): fptr은 포인터
	(double): 매개변수 선언이 double 하나
	
	만약 반환형이 double, 매개변수가 double과 int라면
	double (*fptr) (double, int); 로 나타낼 수 있다.
	이렇게하고 fptr = SimpleFunc 한 뒤, fptr(3,4)의 결과를 확인하면 SimpleFunc(3,4)의 결과와 같게 나온다

	매개변수로 함수 포인터가 전달될 수 있다. 이는 매우 중요한 사실이다.
*/