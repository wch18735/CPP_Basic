#include<stdio.h>

int main() {
	int num1 = 13;	// 00000000 00000000 00000000 00001101
	int num2 = 7;	// 00000000 00000000 00000000 00000111
	
	// & 연산자 : AND (둘 다 1이면 1)
	printf("%d와 %d의 & 연산: %d \n", num1, num2, num1&num2);

	// | 연산자 : OR (하나라도 1이면 1)
	printf("%d와 %d의 | 연산: %d \n", num1, num2, num1|num2);

	// ^ 연산자 : XOR (서로 다를 때 1)
	printf("%d와 %d의 ^ 연산: %d \n", num1, num2, num1^num2);

	// ~ 연산자 : NOT (1이면 0, 0이면 1)
	printf("%d와 %d의 ~ 연산: %d, %d \n", num1, num2, ~num1, ~num2);

	// << 연산자 (0이 채워지면 곱하기 2, 1이 채워지면 곱하기 2, 더하기 1을 해줌)
	printf("%d와 %d의 <<2 연산: %d, %d \n", num1, num2, num1 << 2, num2 << 2);

	// >> 연산자 (나누기 2하며 나머지는 버림, 채워질 때 0을 채울지 1을 채울지는 부로 유지 여부 시스템에 따라 달라짐)
	printf("%d와 %d의 <<2 연산: %d, %d \n", num1, num2, num1 >> 2, num2 >> 2);

	printf("-16의 Shift 연산 >> 2 : %d \n", -16 >> 2);
	// 결과로 -2가 나온다. 이는 당겨올 때 1을 채워주며 부호를 유지한다는 뜻이다.

	// 음의 정수 크기 확인: ~num + 1을 해준다

}

/* 정수의 표현 방식  */
// 음의 정수 표현
// 1) 각 비트별로 보수를 취한다
// 2) +1을 해준다

/* 실수의 표현 방식 */
/*
	1) 부호의 표현을 갖는 바이트 1개
	2) 나머지 7bit 은 exponential
	3) 뒤의 1byte는 1.m 의 m을 담당한다

	=> 따라서 부동소수점 실수 표현은 항상 오차를 가진다.
	0.1은 사실 정확하게 0.1을 나타내는 것이 아니다.
	이는 C언어만의 문제가 아니라 다른 프로그래밍 언어에도 존재하는 문제이다.
*/